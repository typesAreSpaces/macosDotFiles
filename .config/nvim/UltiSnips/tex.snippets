# Accent-related

snippet ;gr "Grave accent" iA
\\\`{$1}$0
endsnippet

snippet ;ac "Acute accent" iA
\\'{$1}$0
endsnippet

snippet ;um "Umlaut accent" iA
\\"{$1}$0
endsnippet

# Math-related
priority 100
snippet ... "ldots" iA
\\dots$0
endsnippet

snippet ;emptys "Empty Set" iA
\\emptyset$0
endsnippet

snippet ;set "Set" iA
\\set{$1 ${2:\mid $3}}$0
endsnippet

snippet ;_ "Subindex" iA
_{$1}$0
endsnippet

snippet ;iff "If and only if" iA
if and only if$0
endsnippet

snippet ;abs "Absolute value" iA
|$1|$0
endsnippet

snippet ;eps "Epsilon" iA
\\epsilon$0
endsnippet

snippet ;inv "Inverse" iA
$1^{-1}$0
endsnippet

priority 100
snippet ;!= "Disequality" iA
\\neq$0
endsnippet

priority 100
snippet ;<= "Less than or Equal to" iA
\\leq$0
endsnippet

priority 100
snippet ;>= "Greather than or Equal to" iA
\\geq$0
endsnippet

snippet OO "Infinity" iA
\\infty$0
endsnippet

snippet ;sos "Sums of squares" iA
\\sum{$1}^2$0
endsnippet

snippet ;( "Parenthesis" iA
($1)$0
endsnippet

snippet ;[ "Squared Parenthesis" iA
[$1]$0
endsnippet

snippet ;<< "Angled Parenthesis" iA
<$1>$0
endsnippet

snippet ;{ "Braces" iA
{$1}$0
endsnippet

snippet ;wrt "with respect to" iA
with respect to$0
endsnippet

snippet ;subse "Subseteq" iA
\\subseteq$0	
endsnippet

snippet ;subss "Subseteq" iA
\\subset$0	
endsnippet

snippet ;supse "Supseteq" iA
\\supseteq$0	
endsnippet

snippet ;supss "Supseteq" iA
\\supset$0	
endsnippet

snippet ;NN "Natural Numbers" iA
\\mathbb{N}$0
endsnippet

snippet ;ZZ "Integer Numbers" iA
\\mathbb{Z}$0
endsnippet

snippet ;QQ "Rational Numbers" iA
\\mathbb{Q}$0
endsnippet

snippet ;RR "Real Numbers" iA
\\mathbb{R}$0
endsnippet

snippet ;CC "Complex Numbers" iA
\\mathbb{C}$0
endsnippet

snippet ;sum "Sum" iA
\\sum_{$1}^{$2}{$3}$0
endsnippet

snippet ;prod "Product" iA
\\prod_{$1}^{$2}{$3}$0
endsnippet

snippet ;lim "Limit" iA
\\lim_{$1 \to $2} $3$0
endsnippet

snippet ;bigconj "Big Conjunction" iA
\\bigwedge_{$1}^{$2}{$3}$0
endsnippet

snippet ;bigdisj "Big Disjunction" iA
\\bigvee_{$1}^{$2}{$3}$0
endsnippet

snippet ;biginter "Big Intersecion" iA
\\bigcap_{$1}^{$2}{$3}$0
endsnippet

snippet ;bigunion "Big Union" iA
\\bigcup_{$1}^{$2}{$3}$0
endsnippet

snippet ;qall "Universal Quantifier" iA
\\qall{$1}{$2}$0
endsnippet

snippet ;qex "Existential Quantifier" iA
\\qex{$1}{$2}$0
endsnippet

snippet ;norm "Norm" iA
\\langle $1 \\rangle$0
endsnippet

snippet ;-> "Arrow" iA
\\rightarrow$0
endsnippet

snippet ;<- "Left arrow" iA
\\leftarrow$0
endsnippet

snippet ;i-> "Injective Arrow" iA
\\xhookrightarrow$0
endsnippet

snippet ;s-> "Surjective Arrow" iA
\\twoheadrightarrow$0
endsnippet

snippet ;=> "Big Arrow" iA
\\Rightarrow$0 
endsnippet

snippet ;join "Join" iA
$1 \\downarrow_{$3} $2$0
endsnippet

snippet ;rrule "Right rule" iA
$2 \rightarrow_{$1} $3$0
endsnippet

snippet ;lrule "Left rule" iA
$2 \leftarrow_{$1} $3$0
endsnippet

snippet ;ideal "Ideal" iA
\\mathfrak{$1}$0
endsnippet

snippet ;field "Field" iA
\\mathscr{$1}$0
endsnippet

snippet ;ring "Ring" iA
\\mathcal{$1}$0
endsnippet

snippet ;bar "Overbar" iA
\\overbar{$1}$0
endsnippet

snippet ;seq "Sequence of symbols" iA
$1_1, \\dots, $1_{$2}$0
endsnippet

snippet ;polyring "Polyring" iA
$1[$2${3:_1, \\dots, $2_{$4}}]
endsnippet

snippet ;bigO "Big-O notation" iA
\\mathcal{O}($1)$0
endsnippet

snippet ;\\ "Backslash" iA
\\textbackslash$0
endsnippet

snippet ;// "Fraction" iA
\\frac{$1}{$2}$0
endsnippet

snippet ;grob "Groebner" iA
Gr\"obner$0
endsnippet

snippet ;piecefun "Big function" iA
\begin{cases}
$1 & $2 \\\\
$3 & $4 \\\\
\end{cases}$0
endsnippet

snippet ;index "Index" iA
[$1 : $2]$0
endsnippet

snippet ;aut "Aut" iA
\\Aut_{$1}{$2}$0
endsnippet

snippet ;spec "Spec" iA
\\spec{$1}$0
endsnippet

snippet ;mspec "m-Spec" iA
\\m-Spec{$1}$0
endsnippet

snippet ;gal "Gal" iA
\\Gal($1)$0
endsnippet

snippet ';prime(\d+)' "LaTeX array" riA
$1^{`!p
primes = ""
for _ in range(0, int(match.group(1))): primes += "\prime"
snip.rv = primes`}$0
endsnippet	

# Latex-related
snippet ;mk "Inline Math" iA
$$1$$0
endsnippet

snippet ;env "General Environment" iA
\begin{$1}
	$0
\end{$1}
endsnippet

snippet ;thm "Theorem Environment" iA
\begin{theorem}
	$0
\end{theorem}
endsnippet

snippet ;proof "Proof Environment" iA
\begin{proof}
	$0
\end{proof}
endsnippet

snippet ;lemma "Lemma Environment" iA
\begin{lemma}
	$0
\end{lemma}
endsnippet

snippet ;def "Definition Environment" iA
\begin{definition}
	$0
\end{definition}
endsnippet

snippet ;remark "Remark Environment" iA
\begin{remark}
	$0
\end{remark}
endsnippet

snippet ;example "Example Environment" iA
\begin{example}
	$0
\end{example}
endsnippet

snippet ;cor "Corollary Environment" iA
\begin{corollary}
	$0
\end{corollary}
endsnippet

snippet ;eq "Equation Environment" iA
\begin{equation*}
	$0
\end{equation*}
endsnippet

snippet ;notation "Notation Environment" iA
\begin{notation}
	$0
\end{notation}
endsnippet

snippet ;enum "Enumerate Environment" iA
\begin{enumerate}
	\item $0
\end{enumerate}
endsnippet

snippet ;itemi "Itemize Environment" iA
\begin{itemize}
	\item $0
\end{itemize}
endsnippet

snippet ;table "Table environment" iA
\begin{table}[${1:htpb}]
	\centering
	\caption{${2:caption}}
	\label{tab:${3:label}}
	\begin{tabular}{${5:c}}
	$0${5/((?<=.)c|l|r)|./(?1: & )/g}
	\end{tabular}
\end{table}
endsnippet

snippet ;fig "Figure environment" iA
\begin{figure}[${1:htpb}]
	\centering
	\includegraphics[width=${3:0.8}\textwidth]{./figures/$2}
	\caption{${4:$2}}
	\label{fig:${5:${2/\W+/-/g}}}
\end{figure}
endsnippet

global !p
def stringify_args(rex):
	stringify = []
	count = 0
	for x in rex.group(1).split(","):
		if(count == 0):
			first_arg = x
		count += 1
		stringify.append("\'" + x + "\'")
	return ' '.join(stringify), first_arg

def stringToPath(s):
  return s.replace(' ', '\\ ')
endglobal

snippet ';intro(\w+[,\w+[\s\w]*]*)  ' "Intro Knowledge" riA
`!p
from os import getcwd
from os import system
from os.path import exists
stringify = []
curr_dir = getcwd()
kldb_file = curr_dir + '/kldb.tex'
kldb_file_path = stringToPath(kldb_file)
if(not(exists(kldb_file))):
	file_cmd = 'touch ' + kldb_file_path
	system(file_cmd)
add_knowledge_cmd='/home/jose/.local/scripts/add-knowledge -p ' +\
kldb_file_path + ' '
args, first_arg = stringify_args(match)
command = 'if ! grep ' + kldb_file_path + ' -e \'index=' + first_arg +\
'}\'; then ' + add_knowledge_cmd + args + '; fi'
system(command)
snip.rv = "\\intro{" + first_arg + '}'
`$0
endsnippet

snippet ;kl "Use Knowledge" iA
\\kl{$1}$0
endsnippet

snippet ';gloss(\w+[,\w+[\s\w]*]*)  ' "Introduce new glossary term" riA
`!p
from os import getcwd
from os import system
from os.path import exists
stringify = []
curr_dir = getcwd()
idxdb_file=curr_dir + '/idxdb.tex'
idxdb_file_path = stringToPath(idxdb_file)
if(not(exists(idxdb_file))):
	file_cmd = 'touch ' + idxdb_file_path
	system(file_cmd)
add_glossary_cmd='/home/jose/.local/scripts/add-glossary -p ' +\
idxdb_file_path + ' '
args, first_arg = stringify_args(match)
command = "if ! grep " + idxdb_file + ' -e \'newglossaryentry{' + first_arg +\
'}\'; then ' + add_glossary_cmd + args + '; fi'
system(command)
snip.rv = "\\glsadd{" + first_arg + '}'
`$0
endsnippet

snippet ;glt "Use Glossary term" iA
\\gls{$1}$0
endsnippet

global !p
def create_matrix_placeholders(snip):
	# Create anonymous snippet body
	anon_snippet_body = ""

	# Get start and end line number of expanded snippet
	start = snip.snippet_start[0]
	end = snip.snippet_end[0]

  # Append current line into anonymous snippet
	for i in range(start, end + 1):
		anon_snippet_body += snip.buffer[i]
		anon_snippet_body += "" if i == end else "\n"

	# Delete expanded snippet line till second to last line
	for i in range(start, end):
		del snip.buffer[start]

	# Empty last expanded snippet line while preserving the line
	snip.buffer[start] = ''

	# Expand anonymous snippet
	snip.expand_anon(anon_snippet_body)

def create_matrix(cols, rows, sep, start, end):
	res = ""
	placeholder = 1
	for _ in range(0, int(rows)):
		res += start + f"${placeholder} "
		placeholder += 1
		for _ in range(0, int(cols) - 1):
			res += sep + f" ${placeholder} "
			placeholder += 1
		res += end
	return res[:-1]
endglobal

post_jump "create_matrix_placeholders(snip)"
snippet ';pmatrix(\d+),(\d+)' "LaTeX pmatrix" br
\begin{pmatrix}
`!p
snip.rv = create_matrix(match.group(1), match.group(2), "&", "\t", "\\\\\\\\\n")
`$0
\end{pmatrix}
endsnippet

post_jump "create_matrix_placeholders(snip)"
snippet ';bmatrix(\d+),(\d+)' "LaTeX bmatrix" br
\begin{bmatrix}
`!p
snip.rv = create_matrix(match.group(1), match.group(2), "&", "\t", "\\\\\\\\\n")
`$0
\end{bmatrix}
endsnippet

post_jump "create_matrix_placeholders(snip)"
snippet ';Bmatrix(\d+),(\d+)' "LaTeX Bmatrix" br
\begin{Bmatrix}
`!p
snip.rv = create_matrix(match.group(1), match.group(2), "&", "\t", "\\\\\\\\\n")
`$0
\end{Bmatrix}
endsnippet

post_jump "create_matrix_placeholders(snip)"
snippet ';det(\d+),(\d+)' "LaTeX vmatrix" br
\begin{vmatrix}
`!p
snip.rv = create_matrix(match.group(1), match.group(2), "&", "\t", "\\\\\\\\\n")
`$0
\end{vmatrix}
endsnippet

snippet ;template "Basic template" iA
\documentclass[a4paper]{article}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{textcomp}
\usepackage[english]{babel}
\usepackage{amsmath, amssymb}

\title{$1}
\author{$2}
\date{\today}

\begin{document}

\maketitle

\begin{abstract}
$3
\end{abstract}

$0

\end{document}
endsnippet
